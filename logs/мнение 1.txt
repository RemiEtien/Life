Идея

Сначала измеряешь фактическую ширину контента таймлайна (contentExtent) и доступную ширину виджета (viewportExtent). Отношение viewportExtent / contentExtent и есть “scale, при котором все влезает” – это твой minScale (фактически fitScale).
Любой масштаб из матрицы TransformationController переводишь в безразмерную величину relativeZoom = currentScale / minScale. Именно её используй для логики уровней: тогда Level 1 всегда relativeZoom = 1, а дальнейшие границы будут одинаково работать на любом устройстве и при любой длине таймлайна.
Расчет уровней

Задай визуальную цель: например, на Level 3 диаметр ноды на экране = 10 logical px (если хочешь физические пиксели – дели на devicePixelRatio).
Для известного радиуса ноды в твоей системе координат (nodeRadiusLogical) вычисли абсолютный масштаб, при котором цель достигается:
scaleForLevel3 = (nodeRadiusLogical * 2) / targetPixelSize.
Граница Level 3 в относительных единицах: relativeZoomLevel3 = scaleForLevel3 / minScale.
Если relativeZoomLevel3 < 1, значит даже в “вмещающем” масштабе нода уже ≥10 px, тогда бери relativeZoomLevel3 = 1 и Level 3 совпадет с Level 1 (узкий таймлайн, крупные ноды).
Границу Level 2 подбираешь из соображений дизайна, например геометрическим средним: relativeZoomLevel2 = sqrt(relativeZoomLevel3). Это гарантирует одинаковое “чувство” шага между уровнями на любых данных.
Максимальный итоговый масштаб: maxScale = minScale * relativeZoomLevel3. Даже если minScale большой (огромный таймлайн), ты всё равно получишь запас для зума, а не “0 диапазона”.
Интеграция с InteractiveViewer

При каждом onInteractionUpdate считай currentScale по матрице, нормализуй в relativeZoom, клади в TransformationController только значения из [1, relativeZoomLevel3], умноженные обратно на minScale. Так жесты пользователя всегда ограничены единым диапазоном.
Состояния UI (годовая/месячная/дневная детализация) переключай по relativeZoom: < level2 → LEVEL 1, level2…level3 → LEVEL 2, >= level3 → LEVEL 3.
При изменении размера экрана или данных пересчитай contentExtent, minScale, потом пересобери границы; текущий relativeZoom сохраняй и переинициализируй матрицу заново, чтобы пользователь оставался на том же логическом уровне, даже если абсолютный масштаб изменился.
Дополнительно

Следи, чтобы все размеры (node radius, thickness линий) были в логических единицах; только конечную цель “10 px” фиксируй тоже в логических единицах, иначе HiDPI даст разные результаты.
Если на Level 3 нужно показать одиночные ноды/дни, ориентируйся не только на размер ноды, но и на желаемый интервал времени в кадре. Можно расширить модель: держать карту zoom → visibleDuration, а размеры элементов вычислять из неё.
После внедрения прогоняй сценарии: короткий таймлайн / длинный / разные устройства, проверяй relativeZoom и итоговые размеры нод, чтобы убедиться, что 10 px реально достигаются.